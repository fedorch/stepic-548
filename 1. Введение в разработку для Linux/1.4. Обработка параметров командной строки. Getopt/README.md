###1.4 Обработка параметров командной строки. Getopt

Большинство программ для Linux имеет множество параметров командной строки, которые
можно указывать при запуске и тем самым менять их поведение. Количество параметров
командной строки для некоторых программ, например, `gcc` не просто велико - оно
огромно.

В большинстве случаев каждая из опций командной строки имеет два варианта: один
короткий и один длинный. Обычно короткие опции предваряются одним знаком дефис `-`,
а длинные двумя `--`. Также короткие опции которые не имеют дополнительных
аргументов можно объединять вместе. Например, команды `ls -l -a` и `ls -la` приведут
к одному и тому же результату. В соответствии со стандартом, длинные опции можно
сокращать до кратчайшей строки, обеспечивающей ей уникальность.

В качестве примера можно посмотреть на описание утилиты [`stat`](stat.txt) которая
показывает информацию о файле. Видно, что большинство параметров имеют, как
короткий, так и длинный варианты.

Как же это выглядит изнутри программы? Параметры передаются в метод `main()` через
два аргумента. Первый это общее число параметров (традиционно называемое `argc`), а
второй - массив указателей на строки (традиционно называемый `argv`). Причем,
самый первый параметр это имя самой программы.

```C
int main(int argc, char *argv[])
```

Для упрощения "жизни" программистов, а также для обеспечения большего единообразия
в обработке параметров командной строки различными программами, в Linux существуют
стандартные функции их обработки. Прочитать описание эти функций можно
[прямо здесь](getopt.txt) или введя команду

```
man 3 getopt
```

Если у вас эта команда не работает, то необходимо предварительно установить
соответствующий раздел руководства.

```
sudo apt-get install manpages-dev
```

В руководстве описаны три функции: `getopt()`, `getopt_long()` и `getopt_long_only()`.
Наиболее интересна функция `getopt_long()`, так как она позволяет задавать сразу
и короткие и длинные обозначения для опций.

Как и в случае функции `getopt()`, все короткие опции задаются в виде строки символов.
Если за символом опции в этой строке следует символ `:`, то значит соответствующая
опция принимает дополнительный параметр.

Основой для работы с длинными опциями служит структура `option`

```C
struct option {
    const char *name;
    int         has_arg;
    int        *flag;
    int         val;
};
```

В этой структуре `name` это полное имя опции (без дефисов). `has_arg` описывает имеет
ли длинная опция аргумент и может принимать три значения (0 — нет аргумента;
1 — обязательный аргумент; 2 — необязательный аргумент). Если указатель `flag` равен
нулю, то функция `getopt_long()` вернет значение из поля `val` в качестве результата.
А если этот указатель не равен нулю, то значение `val` будет записано в ячейку
памяти куда указывает `flag`, а функция `getopt_long()` вернет в качестве результата
своей работы 0.

Если задать значение `flag` равным нулю, а в `val` поместить символьную константу
соответствующую аналогичной короткой опции, то обрабатывать и короткие и длинные
опции можно будет совершенно единообразно.

Вот примеры кода, приведенные в стандартном руководстве [`getopt.c`](getopt.c) и
[`getopt_long.c`](getopt_long.c).

И пара статей для более детального изучения вопроса:

####[Разбор опций командной строки в UNIX-подобных системах](https://habrahabr.ru/post/55665/)

Примеры кода из первой статьи: [`getopt.c`](habrahabr/getopt.c) и
[`getopt_long.c`](habrahabr/getopt_long.c)

####[Обработка команд при помощи getopt()](https://www.ibm.com/developerworks/ru/library/au-unix-getopt/)

Примеры кода из второй статьи: [`getopt_demo.c`](ibm/getopt_demo.c) и
[`getopt_long_demo.c`](ibm/getopt_long_demo.c)
