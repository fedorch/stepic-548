###1.3. Runtime линковка. Libdl

Во всех рассмотренных ранее случаях и при компоновке программы, как со статической,
так и с динамической библиотекой, эти библиотеки уже должны быть на компьютере.
И связывание исполнимого файла с ними достаточно жесткое.

В ряде случаев бывает необходимо подключать внешние динамические библиотеки не
на этапе сборки приложения, а уже при его выполнении. Например, таким образом к
программе могут подключаться разнообразные расширения "плагины", которых на момент
сборки программы ещё может не существовать в природе.

Для загрузки динамических библиотек и вызова, расположенных там функций,
непосредственно в процессе исполнения программы служит специальный системный
интерфейс `libdl`. Это набор функций в системной динамической библиотеке при
помощи которых можно загрузить произвольную библиотеку в память, просмотреть
какие символы (в том числе функции) есть в этой библиотеке, а затем вызвать
их исполнение.

Рассмотрим простейший пример применения интерфейса `libdl` для загрузки нашей
библиотеки `libHello.so`. Файл [`main.c`](main.c)

```C
#include <stddef.h>
#include <stdbool.h>
#include <stdio.h>
#include <dlfcn.h>

void (*hello_message)(const char *);

bool init_library()
{
    void *hdl = dlopen("./libHello.so", RTLD_LAZY);
    if(NULL == hdl)
        return false;

    hello_message = (void(*)(const char *))dlsym(hdl, "hello_message");
    if(NULL == hello_message)
        return false;

    return true;
}

int main()
{
    if(init_library())
        hello_message("Vasya");
    else
        printf("Library was not loaded\n");
    return 0;
}
```

Начнём с подключаемых заголовочных файлов: `stdbool.h` нужен для получения значения
констант `true` и `false`, `stdio.h` для использования функции `printf()`, `stddef.h`
даёт определение нулевого указателя `NULL`, а в `dlfcn.h` описаны функции `dlopen()`
и `dlsym()`.

Добавим к нашей программе указатель на функцию `hello_message()`, а затем напишем
функцию `init_library()` которая будет загружать библиотеку и инициализировать этот
указатель.

Функция `dlopen()` нужна чтобы загрузить библиотеку в память. Ей мы передаём имя
библиотеки (вместе с путем). Второй параметр `RTLD_LAZY` означает, что библиотека
будет загружена в память только тогда, когда программа попытается обратиться к её
содержимому, а не сразу в момент вызова функции `dlopen()`.

Далее, используя указатель `hdl`, который возвращает функция `dlopen()` мы вызываем
функцию `dlsym()` которая находит в загруженной библиотеке и возвращает нам указатель
на требуемую функцию `hello_message()`. Оба раза мы проверяем, что вызовы системных
функций завершились успешно, сравнивая результат, который они возвращают с `NULL`.

Функция `dlsym()` возвращает `void *` то есть не типизированный указатель который
мы должны сами привести к указателю на функцию прототип которой нам должен быть
известен.

Наконец в функции `main()` производится проверка, что загрузка библиотеки прошла
успешно и вызывается функция `hello_message()`. Если же библиотеку загрузить не
удалось или в ней отсутствует символ (функция) `hello_message`, то программа
выдаёт сообщение об ошибке.

Также требуется небольшая модификация [`Makefile`](Makefile), так как наша программа
более напрямую не зависит от библиотеки `libHello.so`, но зато ей требуется
библиотека `libdl`

```
all: exe lib

exe: main.c
	gcc main.c -fPIC -ldl -o hello

lib: hello.c hello.h
	gcc -shared hello.c -fPIC -o libHello.so

clean:
	-rm hello libHello.so 2>/dev/null
```

Если после сборки приложения запустить команду `ldd hello`, то можно убедиться,
что наше приложение более формально не зависит от библиотеки `libHello.so`.

Более подробно с данной темой можно ознакомиться в статье "[Анатомия динамических
библиотек Linux](http://www.ibm.com/developerworks/ru/library/l-dynamic-libraries/)".
